# 2.23 

**1.**回顾ch6的文件系统设计和继续推进ch7的学习，主要是管道通信和异步信号

**2.**

​	**疑问一：**为什么ch7要用统一的Fd枚举，而不是像ch6那样分开管理？想是为了后来的枚举拓展只需扩展Fd枚举，无需修改系统调用了吧

​	**疑问二：**管道如何同步？读端 ：当缓冲区为空时阻塞，等待数据，写端 ：当缓冲区满时阻塞，等待空间，最后关闭检测 ：当写端关闭时，读端返回

​	**疑问三：**fork和exec时信号状态如何继承？

​		fork时 ：

子进程完全复制父进程的信号状态

复制 received 、 mask 、 actions 配置

使用 signal.from_fork() 方法创建新实例

​		exec时 ：

保留进程身份，但重置部分信号状态

保留 mask 设置（信号屏蔽字）

重置 received 集合（清空未处理信号）

重置 actions 为默认值（除非设置了SA_ONEXIT标志）





# 2.25

**1.**问题：怎么看待此组件化内核？

​	1.**渐进升级：**让我们逐步理解每个组件的作用，而不是一开始接触复杂的内核，降低难度的同时对各个组件的理解更加深入。

​	2.**从“调用者”变为“定义者”：**各个组件提供了明确的功能，但是通过Rust的抽象特点如trait机制，我们可以自己实现相关的功能而不是直接调用特定的方法，而且，各个功能如trace等可以逐步升级以适应不同局面，这就充分发挥了我们的主观能动性，在这样的一个环境中我们通过AI来寻找问题的答案，加深我们的理解

​	3.**善用AI工具：**带着问题去求证，通过AI快速获取吸收，这个过程正是将优秀经验化为我们自己的深刻理解的**主动学习闭环**。

**2.当前进度：**在AI的辅助下完成了对ch7的理解

​	1.**信号**：理解了信号处理handle_signals机制：信号可能会随时到达，所以进行异步receive，然后在系统调用返回前进行统一处理，这样就可以仅在内核态进行处理，不需要频繁查看。

​	2.**管道**：和信号类似，写入可以是异步的(Arc保证多个持有，Mutex保证同时只能有一个写入，防止数据损坏)，然后在需要时read



# 2.26

**1.**问题一：既然能通过银行家算法进行预测，为什么还要加Mutex等锁进行互斥？

​	Mutex互斥锁主要是用来保证临界区的互斥访问，防止数据竞争和因此造成的数据损毁，而银行家算法是预测和避免死锁，重点在于预测

**2.Finished：**

​	ch8主要是实现了银行家算法并为此而做出的改动，如Semaphore和Mutex添加了更新分配矩阵，在经历了ch1-7各个功能的迭代后和Ai对于相关实现的建议后，最终完成了ch8实验。

**3.**感悟：
	回顾整个过程中，主要是遇到了两个难点：一是相关概念不清楚或者完全不知道，二是每一次的迭代更新任务，不知从何下手添加需要的字段如信号量分配矩阵allocation_sem等，而Ai这位硅基老师对此却是很拿手，尤其是难点二，他对于文本任务的分析能力极强，然后罗列出来你需要添加的字段，很少漏掉(第一次漏了后程序卡死后再分析一遍即可)重要的字段

​	但是，现在AI还没有达到能够完全代替人脑思考的程度，以一直在用Trae的IDE和内置的GLM4.7(5.0用的人有点多，过年和之前还好，尤其是过了年，排队比较多，相应比较慢)为例，Ai分析我们的代码程序经常陷入某种奇怪的循环中，无论是电脑关机重启或者是开启新的对话和换模型，都没办法完全解决，只能我们亲自指出才能让其"恍然大悟"，这也恰恰说明了现在的时代条件下，优秀的程序员要学会驾驭AI，在AI的辅助下真正地学习和进步，而不是全盘依赖。

​	这可能就是蒋炎岩老师说的"AI是人类的，也是反人类"了吧

