# 2.23 

**1.**回顾ch6的文件系统设计和继续推进ch7的学习，主要是管道通信和异步信号

**2.**

​	**疑问一：**为什么ch7要用统一的Fd枚举，而不是像ch6那样分开管理？想是为了后来的枚举拓展只需扩展Fd枚举，无需修改系统调用了吧

​	**疑问二：**管道如何同步？读端 ：当缓冲区为空时阻塞，等待数据，写端 ：当缓冲区满时阻塞，等待空间，最后关闭检测 ：当写端关闭时，读端返回

​	**疑问三：**fork和exec时信号状态如何继承？

​		fork时 ：

子进程完全复制父进程的信号状态

复制 received 、 mask 、 actions 配置

使用 signal.from_fork() 方法创建新实例

​		exec时 ：

保留进程身份，但重置部分信号状态

保留 mask 设置（信号屏蔽字）

重置 received 集合（清空未处理信号）

重置 actions 为默认值（除非设置了SA_ONEXIT标志）





# 2.25

**1.**问题：怎么看待此组件化内核？

​	1.**渐进升级：**让我们逐步理解每个组件的作用，而不是一开始接触复杂的内核，降低难度的同时对各个组件的理解更加深入。

​	2.**从“调用者”变为“定义者”：**各个组件提供了明确的功能，但是通过Rust的抽象特点如trait机制，我们可以自己实现相关的功能而不是直接调用特定的方法，而且，各个功能如trace等可以逐步升级以适应不同局面，这就充分发挥了我们的主观能动性，在这样的一个环境中我们通过AI来寻找问题的答案，加深我们的理解

​	3.**善用AI工具：**带着问题去求证，通过AI快速获取吸收，这个过程正是将优秀经验化为我们自己的深刻理解的**主动学习闭环**。

**2.当前进度：**在AI的辅助下完成了对ch7的理解

​	1.**信号**：理解了信号处理handle_signals机制：信号可能会随时到达，所以进行异步receive，然后在系统调用返回前进行统一处理，这样就可以仅在内核态进行处理，不需要频繁查看。

​	2.**管道**：和信号类似，写入可以是异步的(Arc保证多个持有，Mutex保证同时只能有一个写入，防止数据损坏)，然后在需要时read